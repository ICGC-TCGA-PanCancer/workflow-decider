.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Sanger::CGP::Pindel::Implement 3"
.TH Sanger::CGP::Pindel::Implement 3 "2014-06-06" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Sanger::CGP::Pindel::Implement \- Implementation functions for use with the PCAP::Threaded <https://github.com/ICGC-TCGA-PanCancer/PCAP-core/blob/dev/lib/PCAP/Threaded.pm> model.
.SH "METHODS"
.IX Header "METHODS"
These are split into 2 sections.
.PP
Threaded Methods are those that use the PCAP::Threaded model to run external processes.
.PP
Helper Methods are those that are either used internally or can be called from the main program.
.SS "Threaded Methods"
.IX Subsection "Threaded Methods"
These methods either use or are intended to be called via the PCAP::Threaded <https://github.com/ICGC-TCGA-PanCancer/PCAP-core/blob/dev/lib/PCAP/Threaded.pm> model.
.PP
\fIinput\fR
.IX Subsection "input"
.PP
Generates input for pindel step.
To be executed within the PCAP::Threaded <https://github.com/ICGC-TCGA-PanCancer/PCAP-core/blob/dev/lib/PCAP/Threaded.pm> model.
.PP
Expected to be run as multiple concurrent (or single series processes), one per input \s-1BAM\s0 (i.e. 2).
.PP
.Vb 6
\&  Arg[1]      : Hashref
\&  Example     : my $threads = PCAP::Threaded\->new($options\->{\*(Aqthreads\*(Aq});
\&                ...
\&                $threads\->add_function(\*(Aqinput\*(Aq, \e&Sanger::CGP::Pindel::Implement::input);
\&                ...
\&                $threads\->run(2, \*(Aqinput\*(Aq, $options);
.Ve
.PP
\fIpindel\fR
.IX Subsection "pindel"
.PP
Runs pindel over input files generated by input.
To be executed within the PCAP::Threaded <https://github.com/ICGC-TCGA-PanCancer/PCAP-core/blob/dev/lib/PCAP/Threaded.pm> model.
.PP
Expected to be run as multiple concurrent (or single series processes), one per reference sequence (bar any excluded items).
.PP
.Vb 8
\&  Arg[1]      : Hashref
\&  Example     : my $threads = PCAP::Threaded\->new($options\->{\*(Aqthreads\*(Aq});
\&                ...
\&                $threads\->add_function(\*(Aqpindel\*(Aq, \e&Sanger::CGP::Pindel::Implement::pindel);
\&                ...
\&                my $jobs = Sanger::CGP::Pindel::Implement::determine_jobs($options);
\&                ...
\&                $threads\->run($jobs, \*(Aqpindel\*(Aq, $options);
.Ve
.PP
\fIpindel_to_vcf\fR
.IX Subsection "pindel_to_vcf"
.PP
Converts raw pindel text alignment output into \s-1VCF\s0 and \s-1SAM\s0 files.
To be executed within the PCAP::Threaded <https://github.com/ICGC-TCGA-PanCancer/PCAP-core/blob/dev/lib/PCAP/Threaded.pm> model.
.PP
Expected to be run as multiple concurrent (or single series processes), one per reference sequence (bar any excluded items).
.PP
.Vb 8
\&  Arg[1]      : Hashref
\&  Example     : my $threads = PCAP::Threaded\->new($options\->{\*(Aqthreads\*(Aq});
\&                ...
\&                $threads\->add_function(\*(Aqpin2vcf\*(Aq, \e&Sanger::CGP::Pindel::Implement::pindel_to_vcf);
\&                ...
\&                my $jobs = Sanger::CGP::Pindel::Implement::determine_jobs($options);
\&                ...
\&                $threads\->run($jobs, \*(Aqpin2vcf\*(Aq, $options);
.Ve
.PP
\fImerge_and_bam\fR
.IX Subsection "merge_and_bam"
.PP
Builds command to merge \s-1VCF\s0 and \s-1BAM\s0 files from individual reference sequenced into single files using bin/pindel_merge_vcf_bam.html,
executed within the PCAP::Threaded <https://github.com/ICGC-TCGA-PanCancer/PCAP-core/blob/dev/lib/PCAP/Threaded.pm> model.
.PP
There should only be a single use of this method in a processing flow, normally the last step.
.PP
If this process has been marked as complete (existence of \f(CW\*(C`tmp/progress/Sanger::CGP::Pindel::Implement::merge_and_bam.0\*(C'\fR) it will not execute.
.PP
On completion progress file is created (\f(CW\*(C`tmp/progress/Sanger::CGP::Pindel::Implement::merge_and_bam.0\*(C'\fR)
.PP
.Vb 7
\&  Arg[1]      : Hashref
\&  Example     : Sanger::CGP::Pindel::Implement::merge_and_bam(
\&                                                    {\*(Aqtmp\*(Aq         => $tmp_dir,
\&                                                     \*(Aqtumour_name\*(Aq => $name_from_tumour_bam,
\&                                                     \*(Aqnormal_name\*(Aq => $name_from_normal_bam,
\&                                                     \*(Aqoutdir\*(Aq      => $dir_for_final_output
\&                                                    });
.Ve
.SS "Helper Methods"
.IX Subsection "Helper Methods"
These methods are general purpose.
.PP
\fIprepare\fR
.IX Subsection "prepare"
.PP
Extracts sample name from respective bam headers and adds to incoming hashref with key suffixed '_name'.
.PP
.Vb 5
\&  Arg[1]      : Hashref
\&  Example     : prepare({\*(Aqtumour\*(Aq=> $tum_bam,
\&                        \*(Aqnormal\*(Aq=> $norm_bam,});
\&  ReturnType  : 1 on success.
\&  Exceptions  : See PCAP::Bam::sample_name
.Ve
.PP
PCAP::Bam::sample_name <https://github.com/ICGC-TCGA-PanCancer/PCAP-core/blob/dev/lib/PCAP/Bam.pm>
.PP
\fIvalid_seqs\fR
.IX Subsection "valid_seqs"
.PP
Returns the list of reference sequences after removing any indicated in the exclude list.
.PP
.Vb 3
\&  Arg[1]      : Hashref
\&  Example     : my @seqs = valid_seqs({\*(Aqexclude\*(Aq => $csv_seq_to_exclude,
\&                                       \*(Aqreference\*(Aq => $path_to_fasta_reference});
.Ve
.PP
\&\f(CW\*(C`exclude\*(C'\fR can include wildcard of \f(CW\*(C`%\*(C'\fR which will match equivalently to \f(CW\*(C`.*\*(C'\fR in a regex.
.PP
my \f(CW$options\fR = shift;
.PP
\fIsanitised_sample_from_bam\fR
.IX Subsection "sanitised_sample_from_bam"
.PP
Gets sample name from \s-1BAM\s0 header and replaces potentially problematic characters with '_'.
.PP
.Vb 4
\&  Arg[1]      : Path to BAM file
\&  Example     : sanitised_sample_from_bam($bam_file_path);
\&  ReturnType  : Scalar (string)
\&  Exceptions  : See PCAP::Bam::sample_name
.Ve
.PP
PCAP::Bam::sample_name <https://github.com/ICGC-TCGA-PanCancer/PCAP-core/blob/dev/lib/PCAP/Bam.pm>
.PP
\fIdetermine_jobs\fR
.IX Subsection "determine_jobs"
.PP
Calculate the number of jobs required for processing following pindel input generation taking into account
any sequences that should be ignored.  Specifically for paired tumour/normal pindel processing.
.PP
.Vb 7
\&  Arg[1]      : Hashref
\&  Example     : my $jobs_required = determine_jobs({\*(Aqtmp\*(Aq => $tmp_dir,
\&                                                    \*(Aqtumour\*(Aq => $tumour_bam,
\&                                                    \*(Aqnormal\*(Aq => $normal_bam,
\&                                                    \*(Aqexclude\*(Aq => $csv_seq_to_exclude,
\&                                                    \*(Aqreference\*(Aq => $path_to_fasta_reference});
\&  ReturnType  : Scalar (int)
.Ve
.PP
\fIfile_list\fR
.IX Subsection "file_list"
.PP
Simple file collation without using expensive glob'ing.
.PP
.Vb 5
\&  Arg[1]      : Path to existing directory
\&  Arg[2]      : regex to match files
\&  Example     : file_list($samp_path, qr/\e.txt$/);
\&  ReturnType  : Array of file names (path not included)
\&  Exceptions  : Autodie based errors on failure to [open|close]dir
.Ve
