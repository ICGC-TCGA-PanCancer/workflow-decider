.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PCAP::Threaded 3"
.TH PCAP::Threaded 3 "2014-04-14" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PCAP::Threaded \- Run threaded processing easily.
.SS "Constructor"
.IX Subsection "Constructor"
.IP "PCAP::Threaded\->new(max_threads)" 4
.IX Item "PCAP::Threaded->new(max_threads)"
Generate a threaded processing object with the defined number of threads.
.SS "Methods"
.IX Subsection "Methods"
.IP "add_function" 4
.IX Item "add_function"
Register a named coderef to be run using threads.
.Sp
.Vb 1
\&  $threads\->add_function($function_name, $coderef [, $divisor]);
\&
\&  function_name \- Text to address function by in L<run()|PCAP::Threaded/run>.
\&  coderef       \- Reference to subroutine.
\&  divisor       \- See L<_suitable_threads()|PCAP::Threaded/_suitable_threads>.
.Ve
.IP "run" 4
.IX Item "run"
Run the named function for the stated number of iterations.
.Sp
\&\s-1NOTE:\s0 If your process needs to honor selected index processing this needs to be handled in the
callback registered in add_function.
.Sp
.Vb 1
\&  $threads\->run($iterations, $function_name, @params);
\&
\&  iterations    \- Number of times the function should be started iteration
\&                  number (origin 1) is passed as first argument to the code\-ref
\&                  defined in L<add_function()|PCAP::Threaded/add_function>.
\&  function_name \- Name of function as defined in L<add_function()|PCAP::Threaded/add_function>.
\&  @params       \- Any additional params for the coderef.
.Ve
.SS "Utility Methods"
.IX Subsection "Utility Methods"
These are non-object methods which are useful to related code
.PP
\fIResume Helpers\fR
.IX Subsection "Resume Helpers"
.PP
These are useful methods to help you program resume from the last successfully completed step.
.PP
It is recommended that you use these in any callbacks used in the
\&\fIrun()\fR function to prevent unnecessary processing after restarting
a job.
.PP
These can also be used for other processes in your program flow that aren't using threads.  Where
these don't require an incrementing index value please use '0' (zero);
.IP "success_exists" 4
.IX Item "success_exists"
\&\fBBefore\fR compute step add this code:
.Sp
.Vb 1
\&  return if PCAP::Threaded::success_exists($tmpdir, $index[, $index_2...]);
.Ve
.Sp
Requires implementation of \fItouch_success()\fR.
.Sp
($index_2... may be useful for some other implementation, see \fIbwa_aln()\fR).
.IP "touch_success" 4
.IX Item "touch_success"
\&\fBAfter\fR compute step add this code:
.Sp
.Vb 1
\&  return if PCAP::Threaded::touch_success($tmpdir, $index[, $index_2...]);
.Ve
.Sp
Requires implementation of \fIsuccess_exists()\fR.
.Sp
($index_2... may be useful for some other implementation, see \fIbwa_aln()\fR).
.IP "external_process_handler" 4
.IX Item "external_process_handler"
.Vb 1
\&  PCAP::Threaded::external_process_handler(File::Spec\->catdir($tmp, \*(Aqlogs\*(Aq), $command, $index[, $index_2...]);
.Ve
.Sp
Wraps up command with stdout and stderr catchalls to keep the output of each threaded process
separated from the script itself.  Added to simplify interpretation of any issues that may occur.
.Sp
($index_2... may be useful for some other implementation, see \fIbwa_aln()\fR).
.SS "Internal functions"
.IX Subsection "Internal functions"
.IP "_suitable_threads" 4
.IX Item "_suitable_threads"
.Vb 1
\&  $self\->_suitable_threads($divisor);
.Ve
.Sp
If the code-ref to be executed uses multiple threads (or piped processes) the total number of
parallel jobs will be divided by this number to prevent over subscription of resources.  Take this
simple example:
.Sp
.Vb 1
\&  grep \-wF \*(Aqwibble\*(Aq | cut \-f 5 | sort | uniq \-c
.Ve
.Sp
This 'pipeline' can theoretically use 4 \s-1CPU\s0's at 100% each.  When executing multiple parallel
executions of this the total number of threads defined on the command line is divided by the
provided value:
.Sp
.Vb 2
\&  max_parallel = int(total_threads / divisor);
\&  max_parallel++ if(max_parallel == 0);
.Ve
.Sp
If total_threads is < divisor a single process will run, any prevention of oversubscription then
falls to the \s-1OS\s0 and any \s-1CPU\s0 affinity settings.
