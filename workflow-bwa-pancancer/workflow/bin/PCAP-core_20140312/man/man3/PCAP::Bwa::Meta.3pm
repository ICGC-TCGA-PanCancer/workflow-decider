.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PCAP::Bwa::Meta 3pm"
.TH PCAP::Bwa::Meta 3pm "2014-03-11" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PCAP::Bwa::Meta \- Object to contain information about input files for mapping.
.SS "Synopsis"
.IX Subsection "Synopsis"
Please use the following to generate these objects:
.PP
.Vb 1
\&  PCAP::Bwa::Meta::files_to_meta($tmp, \e@files)
.Ve
.PP
This accepts bam, paired fastq and interleaved fastq.  Fastq files can be gzip compressed.
The calling program should decide which type of files it is able to process.
.SS "Constructor"
.IX Subsection "Constructor"
.IP "new" 4
.IX Item "new"
Generates the object when called with hashref of options, please use
files_to_meta to generate the objects.
.IP "files_to_meta" 4
.IX Item "files_to_meta"
Generates a set of PCAP::Bwa::Meta objects based on the input files.
.Sp
.Vb 1
\&  my $meta_set = PCAP::Bwa::Meta::files_to_meta($tmpdir, \e@files);
.Ve
.Sp
Returns a array reference of checked and pre-processed information.
.SS "Object Methods"
.IX Subsection "Object Methods"
.IP "in" 4
.IX Item "in"
Can store \s-1BAM\s0, \s-1FASTQ\s0 or \s-1INTERLEAVED\s0 \s-1FASTQ\s0
.Sp
Retrieve the original file path.  In the case of a paired \s-1FASTQ\s0 file this will be truncated back to
the common part of the filename so that both elements are represented by one object.
.Sp
.Vb 2
\&  FASTQ 1: /somepath/xxx_1.fq.gz
\&  FASTQ 2: /somepath/xxx_2.fq.gz
\&
\&  in = /somepath/xxx
.Ve
.IP "tstub" 4
.IX Item "tstub"
A path for files generated from the input file represented here.  The path is constructed from
\&'temp' and the rg_id.
.IP "fastq" 4
.IX Item "fastq"
Extension type of fastq file, see parser_fastq_filename.
.IP "paired_fq" 4
.IX Item "paired_fq"
Flag to indicate that content of \fIin()\fR is a stub for paired fastq rather
than an interleaved fastq, see parser_fastq_filename.
.Sp
Added for future compatibility with files that can be used with '\s-1BWA\s0 mem'.
.IP "fastq" 4
.IX Item "fastq"
When input is some form of fastq this returns the extension, otherwise undef.
.IP "paired_fq" 4
.IX Item "paired_fq"
When input is a paired fastq file this returns true.
.IP "rg" 4
.IX Item "rg"
Returns the \s-1RG_ID\s0 that has been applied to this input.
.IP "rg_header" 4
.IX Item "rg_header"
Call this with a hash of \s-1RG\s0 header tags to generate and retrieve the header, e.g.
.Sp
.Vb 1
\&  $meta\->rg_header(q{\et}, \-SN => \*(Aqsome_sample_name\*(Aq, \-LB => \*(Aqlibrary_name\*(Aq);
.Ve
.Sp
After generation you can retrieve with the required separator ('\et' for passing string to bwa on
command line, \*(L"\et\*(R" for direct use):
.Sp
.Vb 1
\&  print $meta\->rg_header(qq{\et})."\en";
\&
\&  $to_pass_to_command = $meta\->rg_header(q{\et});
.Ve
.Sp
\&\s-1SN\s0 is the only required element at present.  See the Samtools specification <http://samtools.sourceforge.net/SAMv1.pdf>
for details.
.SS "Utility Methods"
.IX Subsection "Utility Methods"
.IP "set_rg_index" 4
.IX Item "set_rg_index"
.Vb 1
\&  PCAP::Bwa::Meta::set_rg_index($int);
.Ve
.Sp
Initialise the \s-1RG\s0 \s-1ID\s0 value to start at this \s-1INTEGER\s0.
.IP "reset_rg_index" 4
.IX Item "reset_rg_index"
.Vb 3
\&  PCAP::Bwa::Meta::next_rg_index();
\&    # or
\&  &PCAP::Bwa::Meta::next_rg_index;
.Ve
.Sp
Reset the \s-1RG\s0 \s-1ID\s0 value to 1.
.IP "is_fastq_ext" 4
.IX Item "is_fastq_ext"
Determines if the file is some form of fastq file.  If not fastq original filename is returned. When
fastq the file extension is removed from the end of the filename and returned as the second argument.
.Sp
.Vb 3
\&  my ($new_name, $ext) = PCAP::Bwa::Meta::is_fastq_ext(\*(Aq1_1.fq\*(Aq);
\&    # $new_name = 1_1
\&    # $ext = \*(Aqfq\*(Aq
\&
\&  my ($new_name, $ext) = PCAP::Bwa::Meta::is_fastq_ext(\*(Aq1_1.bam\*(Aq);
\&    # $new_name = 1_1.bam
\&    # $ext = undef
.Ve
.Sp
Understands the following as fastq files:
.Sp
.Vb 4
\&  fastq
\&  fastq.gz
\&  fq
\&  fq.gz
.Ve
.IP "parse_fastq_filename" 4
.IX Item "parse_fastq_filename"
Takes a fastq filename after removal of the extension (see \*(L"PCAP::Bwa::Meta/is_fastq_ext\*(R" in \fIis_fastq_ext()\fR
and determines if file is read1, read2 or interleaved fastq.
.Sp
Expects file to end '_1' or '_2' for paired, assumed interleaved otherwise.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 269:" 4
.IX Item "Around line 269:"
You forgot a '=back' before '=head2'
